import zh from "../messagesJson/zh.json";
export const PartialMessages = {
    zh: {
        "(BETA) Always overwrite with a newer file": "始终使用更新的文件覆盖(测试版)",
        "(Beta) Use ignore files": "(测试版)使用忽略文件",
        "(Days passed, 0 to disable automatic-deletion)": "(已过天数,0为禁用自动删除)",
        "(ex. Read chunks online) If this option is enabled, LiveSync reads chunks online directly instead of replicating them locally. Increasing Custom chunk size is recommended.": "(例如,在线读取块)如果启用此选项,LiveSync 将直接在线读取块,而不是在本地复制块。建议增加自定义块大小",
        "(MB) If this is set, changes to local and remote files that are larger than this will be skipped. If the file becomes smaller again, a newer one will be used.": "(MB)如果设置了此项,大于此大小的本地和远程文件的更改将被跳过。如果文件再次变小,将使用更新的文件",
        "(Mega chars)": "(百万字符)",
        "(Not recommended) If set, credentials will be stored in the file.": "(不建议)如果设置,凭据将存储在文件中",
        "(Obsolete) Use an old adapter for compatibility": "(已弃用)为兼容性使用旧适配器",
        "Access Key": "访问密钥",
        "Always prompt merge conflicts": "始终提示合并冲突",
        "Algorithm": "算法",
        "Apply Latest Change if Conflicting": "如果冲突则应用最新更改",
        "Apply preset configuration": "应用预设配置",
        "Automatically Sync all files when opening Obsidian.": "打开 Obsidian 时自动同步所有文件",
        "Batch database update": "批量数据库更新",
        "Batch limit": "批量限制",
        "Batch size": "批量大小",
        "Batch size of on-demand fetching": "按需获取的批量大小",
        "Before v0.17.16, we used an old adapter for the local database. Now the new adapter is preferred. However, it needs local database rebuilding. Please disable this toggle when you have enough time. If leave it enabled, also while fetching from the remote database, you will be asked to disable this.": "在 v0.17.16 之前,我们使用旧适配器作为本地数据库。现在首选新适配器。但是,它需要重建本地数据库。请在有足够时间时禁用此开关。如果保持启用状态,并且在从远程数据库获取时,系统将要求您禁用此开关。",
        "Bucket Name": "存储桶名称",
        "cmdConfigSync.showCustomizationSync": "显示自定义同步",
        "Comma separated `.gitignore, .dockerignore`": "用逗号分隔,例如 `.gitignore, .dockerignore`",
        "Compute revisions for chunks (Previous behaviour)": "为 chunks 计算修订版本(以前的行为)",
        "Custom Headers": "自定义标题",
        "Custom headers for requesting the CouchDB. e.g. `x-custom-header1: value1\n x-custom-header2: value2`": "请求存储桶的自定义头部。例如： ”x-custom-header1: value1\n x-custom-header2: value2”",
        "Data Compression": "数据压缩",
        "Database Name": "数据库名称",
        "Database suffix": "数据库后缀",
        "Delay conflict resolution of inactive files": "推迟解决不活动文件",
        "Delay merge conflict prompt for inactive files.": "推迟手动解决不活动文件",
        "Delete old metadata of deleted files on start-up": "启动时删除已删除文件的旧元数据",
        "Device name": "设备名称",
        "dialog.yourLanguageAvailable": "Self-hosted LiveSync已提供您语言的翻译,因此启用了%{Display language}\n\nNote: Not all messages are translated. We are waiting for your contributions!\nNote 2: If you create an Issue, **please revert to %{lang-def}** and then take screenshots, messages and logs. This can be done in the setting dialogue.\nMay you find it easy to use!",
        "dialog.yourLanguageAvailable.btnRevertToDefault": "保持%{lang-def}",
        "dialog.yourLanguageAvailable.Title": " 翻译可用!",
        "Disables logging, only shows notifications. Please disable if you report an issue.": "禁用日志记录,仅显示通知。如果您报告问题,请禁用此选项",
        "Display Language": "显示语言",
        "Do not check configuration mismatch before replication": "在复制前不检查配置不匹配",
        "Do not keep metadata of deleted files.": "不保留已删除文件的元数据 ",
        "Do not split chunks in the background": "不在后台分割 chunks",
        "Do not use internal API": "不使用内部 API",
        "Doctor.Button.DismissThisVersion": "拒绝,并且直到下个版本前不再询问",
        "Doctor.Button.Fix": "修复",
        "Doctor.Button.FixButNoRebuild": "修复但不重建",
        "Doctor.Button.No": "拒绝",
        "Doctor.Button.Skip": "保持不变",
        "Doctor.Button.Yes": "确定",
        "Doctor.Dialogue.Main": "您好！配置医生已根据您的要求启动(感谢您)！！遗憾的是,检测到部分配置存在潜在问题。请放心,我们将逐一解决这些问题。\n\n提前告知您,我们将就以下事项进行确认：\n\n为数据块计算修订版本(此前行为)\n增强块大小\n\n我们开始处理吗?",
        "Doctor.Dialogue.MainFix": "\n## ${name}\n\n| Current | Ideal |\n|:---:|:---:|\n| ${current} | ${ideal} |\n\n**Recommendation Level:** ${level}\n\n### Why this has been detected?\n\n${reason}\n\n${note}\n\nFix this to the ideal value?",
        "Doctor.Dialogue.Title": "Self-hosted LiveSync 配置诊断",
        "Doctor.Dialogue.TitleAlmostDone": "全部完成!",
        "Doctor.Dialogue.TitleFix": "修复问题${current}/${total}",
        "Doctor.Level.Must": "必须",
        "Doctor.Level.Necessary": "必要",
        "Doctor.Level.Optional": "可选",
        "Doctor.Level.Recommended": "推荐",
        "Doctor.Message.NoIssues": "未发现问题!",
        "Doctor.Message.RebuildLocalRequired": "注意！需要重建本地数据库以应用此项！",
        "Doctor.Message.RebuildRequired": "注意！需要重建才能应用此项！",
        "Doctor.Message.SomeSkipped": "我们将某些问题留给了以后处理。是否要在下次启动时再次询问您？",
        "Doctor.RULES.E2EE_V02500.REASON": "The End-to-End Encryption has got now more robust and faster. Also because, the previous E2EE was found to be compromised in a re-conducted code review. It should be applied as soon as possible. Really apologises for your inconvenience. And, this setting is not forward compatible. All synchronised devices must be updated to v0.25.0 or higher. Rebuilds are not required and will be converted from the new transfer to the new format, However, it is recommended to rebuild whenever possible.",
        "Enable advanced features": "启用高级功能",
        "Enable customization sync": "启用自定义同步",
        "Enable Developers' Debug Tools.": "启用开发者调试工具 ",
        "Enable edge case treatment features": "启用边缘情况处理功能",
        "Enable poweruser features": "启用高级用户功能",
        "Enable this if your Object Storage doesn't support CORS": "如果您的对象存储不支持 CORS,请启用此功能 ",
        "Enable this option to automatically apply the most recent change to documents even when it conflicts": "启用此选项可在文档冲突时自动应用最新的更改",
        "End-to-End Encryption Algorithm": "端到端加密算法",
        "Encrypt contents on the remote database. If you use the plugin's synchronization feature, enabling this is recommended.": "加密远程数据库中的内容。如果您使用插件的同步功能,则建议启用此功能 ",
        "Encrypting sensitive configuration items": "加密敏感配置项",
        "Encryption phassphrase. If changed, you should overwrite the server's database with the new (encrypted) files.": "加密密码。如果更改,您应该用新的(加密的)文件覆盖服务器的数据库 ",
        "End-to-End Encryption": "端到端加密",
        "Endpoint URL": "Endpoint URL",
        "Enhance chunk size": "增强块大小",
        "Fetch chunks on demand": "按需获取块",
        "Fetch database with previous behaviour": "使用以前的行为获取数据库",
        "Filename": "文件名",
        "Forces the file to be synced when opened.": "打开文件时强制同步该文件 ",
        "Handle files as Case-Sensitive": "将文件视为区分大小写",
        "If disabled(toggled), chunks will be split on the UI thread (Previous behaviour).": "如果禁用(切换),chunks 将在 UI 线程上分割(以前的行为)",
        "If enabled per-filed efficient customization sync will be used. We need a small migration when enabling this. And all devices should be updated to v0.23.18. Once we enabled this, we lost a compatibility with old versions.": "如果启用,将使用基于文件的、高效的自定义同步。启用此功能需要进行一次小的迁移。所有设备都应更新到 v0.23.18。一旦启用此功能,我们将失去与旧版本的兼容性",
        "If enabled, chunks will be split into no more than 100 items. However, dedupe is slightly weaker.": "如果启用,数据块将被分割成不超过 100 项。但是,去重效果会稍弱",
        "If enabled, newly created chunks are temporarily kept within the document, and graduated to become independent chunks once stabilised.": "如果启用,新创建的数据块将暂时保留在文档中,并在稳定后成为独立数据块",
        "If enabled, the file under 1kb will be processed in the UI thread.": "如果启用,小于 1kb 的文件将在 UI 线程中处理",
        "If enabled, the notification of hidden files change will be suppressed.": "如果启用,隐藏文件更改的通知将被抑制",
        "If this enabled, all chunks will be stored with the revision made from its content. (Previous behaviour)": "如果启用,所有 chunks 将使用根据其内容生成的修订版本存储(以前的行为)",
        "If this enabled, All files are handled as case-Sensitive (Previous behaviour).": "如果启用,所有文件都将视为区分大小写(以前的行为)",
        "If this enabled, chunks will be split into semantically meaningful segments. Not all platforms support this feature.": "如果启用此功能,数据块将被分割成具有语义意义的段落。并非所有平台都支持此功能",
        "If this is set, changes to local files which are matched by the ignore files will be skipped. Remote changes are determined using local ignore files.": "如果设置了此项,与忽略文件匹配的本地文件的更改将被跳过。远程更改使用本地忽略文件确定",
        "If this option is enabled, PouchDB will hold the connection open for 60 seconds, and if no change arrives in that time, close and reopen the socket, instead of holding it open indefinitely. Useful when a proxy limits request duration but can increase resource usage.": "如果启用此选项,PouchDB 将保持连接打开 60 秒,如果在此时间内没有更改到达,则关闭并重新打开套接字,而不是无限期保持打开。当代理限制请求持续时间时有用,但可能会增加资源使用ß",
        "If enabled, the ⛔ icon will be shown inside the status instead of the file warnings banner. No details will be shown.": "启用后,状态栏将显示⛔图标而非文件警告横幅。不会显示详细信息",
        "If this enabled, JWT will be used for authentication.": "如果启用此功能,将使用JWT进行身份验证",
        "If enabled, the request API will be used to avoid `inevitable` CORS problems. This is a workaround and may not work in all cases. PLEASE READ THE DOCUMENTATION BEFORE USING THIS OPTION. This is a less-secure option.": "启用此选项后,请求将通过API进行,以规避'不可避免'的跨域资源共享(CORS)问题。此为临时解决方案,可能无法在所有场景下生效。使用前请务必阅读文档说明。此选项安全性较低",
        "If enabled, the file properties will be encrypted in the remote database. This is useful for protecting sensitive information in file paths, sizes, and IDs of its chunks. If you are using V1 E2EE, this only obfuscates the file path.": "启用后,文件属性将在远程数据库中加密存储。此功能有助于保护文件路径、大小及其数据块ID等敏感信息。若使用V1端到端加密,仅对文件路径进行混淆处理",
        "Ignore files": "忽略文件",
        "Incubate Chunks in Document": "在文档中孵化块(测试版)",
        "Interval (sec)": "间隔(秒)",
        "K.exp": "实验性",
        "K.long_p2p_sync": "%{title_p2p_sync} (%{exp})",
        "K.P2P": "%{Peer}-to-%{Peer}",
        "K.Peer": "Peer",
        "K.ScanCustomization": "扫描自定义",
        "K.short_p2p_sync": "P2P同步(%{exp})",
        "K.title_p2p_sync": "Peer-to-Peer同步",
        "Keep empty folder": "保留空文件夹",
        "lang_def": "Default",
        "lang-de": "Deutsche",
        "lang-def": "%{lang_def}",
        "lang-es": "Español",
        "lang-ja": "日本語",
        "lang-ko": "한국어",
        "lang-ru": "Русский",
        "lang-zh": "简体中文",
        "lang-zh-tw": "繁體中文",
        "LiveSync could not handle multiple vaults which have same name without different prefix, This should be automatically configured.": "LiveSync 无法处理具有相同名称但没有不同前缀的多个库。这应该自动配置",
        "liveSyncReplicator.beforeLiveSync": "在LiveSync前,先启动OneShot一次...",
        "liveSyncReplicator.cantReplicateLowerValue": "我们无法复制更小的值",
        "liveSyncReplicator.checkingLastSyncPoint": "查找上次同步点",
        "liveSyncReplicator.couldNotConnectTo": "无法连接到 ${uri} : ${name}\n(${db})",
        "liveSyncReplicator.couldNotConnectToRemoteDb": "无法连接到远程数据库：${d}",
        "liveSyncReplicator.couldNotConnectToServer": "无法连接到服务器",
        "liveSyncReplicator.couldNotConnectToURI": "无法连接到 ${uri}:${dbRet}",
        "liveSyncReplicator.couldNotMarkResolveRemoteDb": "无法标记并解决远程数据库",
        "liveSyncReplicator.liveSyncBegin": "LiveSync 开始...",
        "liveSyncReplicator.lockRemoteDb": "锁定远程数据库以防止数据损坏",
        "liveSyncReplicator.markDeviceResolved": "将此设备标记为“已解决”",
        "liveSyncReplicator.oneShotSyncBegin": "OneShot同步开始...(${syncMode})",
        "liveSyncReplicator.remoteDbCorrupted": "远程数据库较新或已损坏,请确保已安装最新版本的self-hosted-livesync",
        "liveSyncReplicator.remoteDbCreatedOrConnected": "远程数据库已创建或连接",
        "liveSyncReplicator.remoteDbDestroyed": "远程数据库已销毁",
        "liveSyncReplicator.remoteDbDestroyError": "远程数据库销毁时发生错误：",
        "liveSyncReplicator.remoteDbMarkedResolved": "远程数据库已标记为已解决",
        "liveSyncReplicator.replicationClosed": "同步已关闭",
        "liveSyncReplicator.replicationInProgress": "同步正在进行中",
        "liveSyncReplicator.retryLowerBatchSize": "使用更小的批量大小重试：${batch_size}/${batches_limit}",
        "liveSyncReplicator.unlockRemoteDb": "解锁远程数据库以防止数据损坏",
        "liveSyncSetting.errorNoSuchSettingItem": "没有此设置项：${key}",
        "liveSyncSetting.originalValue": "原始值：${value}",
        "liveSyncSetting.valueShouldBeInRange": "值应该在 ${min} < value < ${max} 之间",
        "liveSyncSettings.btnApply": "应用",
        "logPane.autoScroll": "自动滚动",
        "logPane.logWindowOpened": "日志窗口已打开",
        "logPane.pause": "暂停",
        "logPane.title": "Self-hosted LiveSync 日志",
        "logPane.wrap": "自动换行",
        "Maximum delay for batch database updating": "批量数据库更新的最大延迟",
        "Maximum file size": "最大文件大小",
        "Maximum Incubating Chunk Size": "最大孵化块大小",
        "Maximum Incubating Chunks": "最大孵化块数",
        "Maximum Incubation Period": "最大孵化期",
        "MB (0 to disable).": "MB(0为禁用)",
        "Memory cache size (by total characters)": "内存缓存大小(按总字符数)",
        "Memory cache size (by total items)": "内存缓存大小(按总项目数)",
        "Minimum delay for batch database updating": "批量数据库更新的最小延迟",
        "Minimum interval for syncing": "最小同步间隔",
        "The minimum interval for automatic synchronisation on event.": "事件发生时自动同步的最小间隔",
        "moduleCheckRemoteSize.logCheckingStorageSizes": "正在检查存储大小",
        "moduleCheckRemoteSize.logCurrentStorageSize": "远程存储大小：${measuredSize}",
        "moduleCheckRemoteSize.logExceededWarning": "远程存储大小：${measuredSize} 超过 ${notifySize}",
        "moduleCheckRemoteSize.logThresholdEnlarged": "阈值已扩大到 ${size}MB",
        "moduleCheckRemoteSize.msgConfirmRebuild": "这可能需要一些时间。您真的想现在重建所有内容吗？",
        "moduleCheckRemoteSize.msgDatabaseGrowing": "**您的数据库正在变大！** 但别担心,我们现在可以解决它。在远程存储空间用完之前还有时间。\n\n| 测量大小 | 配置大小 |\n| --- | --- |\n| ${estimatedSize} | ${maxSize} |\n\n> [!MORE]-\n> 如果您已经使用了很多年,数据库中可能会积累未引用的 chunks——也就是垃圾。因此,我们建议重建所有内容。它可能会变得小得多。\n> \n> 如果您的库容量只是在增加,最好在整理文件后重建所有内容。即使您为了加速过程删除了文件,Self-hosted LiveSync 也不会删除实际数据。这大致[有文档记录](https://github.com/vrtmrz/obsidian-livesync/blob/main/docs/tech_info.md)。\n> \n> 如果您不介意增加,可以将通知限制增加 100MB。如果您在自己的服务器上运行,就是这种情况。但是,最好还是不时地重建所有内容。\n> \n\n> [!WARNING]\n> 如果您执行重建所有内容,请确保所有设备都已同步。尽管如此,插件会尽可能地合并\n",
        "moduleCheckRemoteSize.msgSetDBCapacity": "我们可以设置一个最大数据库容量警告,**以便在远程存储空间耗尽前采取行动**。\n您想启用这个功能吗?\n\n> [!MORE]-\n> - 0: 不警告存储大小。\n>   如果您在远程存储(尤其是自托管)上有足够的空间,则推荐此选项。您可以手动检查存储大小并重建。\n> - 800: 如果远程存储大小超过 800MB 则发出警告。\n>   如果您使用的是 fly.io(1GB 限制) 或 IBM Cloudant,则推荐此选项。\n> - 2000: 如果远程存储大小超过 2GB 则发出警告。\n\n如果达到限制,系统会要求我们逐步增大限制\n",
        "moduleCheckRemoteSize.option2GB": "2GB (标准)",
        "moduleCheckRemoteSize.option800MB": "800MB (Cloudant, fly.io)",
        "moduleCheckRemoteSize.optionAskMeLater": "稍后问我",
        "moduleCheckRemoteSize.optionDismiss": "忽略",
        "moduleCheckRemoteSize.optionIncreaseLimit": "增加到 ${newMax}MB",
        "moduleCheckRemoteSize.optionNoWarn": "不,请永远不要警告",
        "moduleCheckRemoteSize.optionRebuildAll": "立即重建所有内容",
        "moduleCheckRemoteSize.titleDatabaseSizeLimitExceeded": "远程存储大小超出限制",
        "moduleCheckRemoteSize.titleDatabaseSizeNotify": "设置数据库大小通知",
        "moduleInputUIObsidian.defaultTitleConfirmation": "确认",
        "moduleInputUIObsidian.defaultTitleSelect": "选择",
        "moduleInputUIObsidian.optionNo": "否",
        "moduleInputUIObsidian.optionYes": "是",
        "moduleLiveSyncMain.logAdditionalSafetyScan": "额外的安全扫描...",
        "moduleLiveSyncMain.logLoadingPlugin": "正在加载插件...",
        "moduleLiveSyncMain.logPluginInitCancelled": "插件初始化被某个模块取消",
        "moduleLiveSyncMain.logPluginVersion": "Self-hosted LiveSync v${manifestVersion} ${packageVersion}",
        "moduleLiveSyncMain.logReadChangelog": "LiveSync 已更新,请阅读更新日志！",
        "moduleLiveSyncMain.logSafetyScanCompleted": "额外的安全扫描完成",
        "moduleLiveSyncMain.logSafetyScanFailed": "额外的安全扫描在某个模块上失败",
        "moduleLiveSyncMain.logUnloadingPlugin": "正在卸载插件...",
        "moduleLiveSyncMain.logVersionUpdate": "LiveSync 已更新,如果存在破坏性更新,所有自动同步已暂时禁用。请确保所有设备都更新到最新版本后再启用",
        "moduleLiveSyncMain.msgScramEnabled": "Self-hosted LiveSync 已被配置为忽略某些事件。这样对吗？\n\n| 类型 | 状态 | 说明 |\n|:---:|:---:|---|\n| 存储事件 | ${fileWatchingStatus} | 所有修改都将被忽略 |\n| 数据库事件 | ${parseReplicationStatus} | 所有同步的更改都将被推迟 |\n\n您想恢复它们并重启 Obsidian 吗？\n\n> [!DETAILS]-\n> 这些标志是在重建或获取时由插件设置的。如果过程异常结束,它们可能会被无意中保留。\n> 如果您不确定,可以尝试重新运行这些过程。请确保备份您的库。\n",
        "moduleLiveSyncMain.optionKeepLiveSyncDisabled": "保持 LiveSync 禁用",
        "moduleLiveSyncMain.optionResumeAndRestart": "恢复并重启 Obsidian",
        "moduleLiveSyncMain.titleScramEnabled": "紧急停止已启用",
        "moduleLocalDatabase.logWaitingForReady": "等待就绪...",
        "moduleLog.showLog": "Show Log",
        "moduleMigration.docUri": "https://github.com/vrtmrz/obsidian-livesync/blob/main/docs/zh/README_zh.md#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8",
        "moduleMigration.fix0256.buttons.checkItLater": "Check it later",
        "moduleMigration.fix0256.buttons.DismissForever": "I have fixed it, and do not ask again",
        "moduleMigration.fix0256.buttons.fix": "Fix",
        "moduleMigration.fix0256.message": "Due to a recent bug (in v0.25.6), some files may not have been saved correctly in the sync database.\nWe have scanned our files and found some that need to be fixed.\n\n**Files ready to be fixed:**\n\n${files}\n\nThese files have size-matched original file on the storage, and are likely to be recoverable.\nWe can use them to fix the database, please click the \"Fix\" button below to fix them.\n\n${messageUnrecoverable}\n\nIf you want to run it again, you can do so from Hatch.\n",
        "moduleMigration.fix0256.messageUnrecoverable": "**Files cannot be fixed on this device:**\n\n${filesNotRecoverable}\n\nThese files have inconsistent metadata, and cannot be fixed on this device (mostly we cannot determine which is correct).\nTo restore them, please check your other devices (also by this feature) or restore them manually from a backup.\n",
        "moduleMigration.fix0256.title": "Broken files has been detected",
        "moduleMigration.insecureChunkExist.buttons.fetch": "I already rebuilt the remote. Fetch from the remote",
        "moduleMigration.insecureChunkExist.buttons.later": "I will do it later",
        "moduleMigration.insecureChunkExist.buttons.rebuild": "Rebuild Everything",
        "moduleMigration.insecureChunkExist.laterMessage": "We strongly recommend to treat this as soon as possible!",
        "moduleMigration.insecureChunkExist.message": "Some chunks are not securely stored and are not encrypted in databases.\n**Please rebuild the database to fix this issue**.\n\nIf your Remote Database is not configured with SSL, or using less-secure credentials, **you are at risk of exposing sensitive data**.\n\nNote: Please upgrade your Self-hosted LiveSync v0.25.6 or higher on all your devices, and back your vault up surely.\nNote2: Rebuild Everything and Fetch consumes a bit of time and traffic, please do it in off-peak hours and ensure a stable network connection.\n",
        "moduleMigration.insecureChunkExist.title": "Insecure chunks found!",
        "moduleMigration.logBulkSendCorrupted": "已启用批量发送 chunks,但此功能已损坏。给您带来不便,我们深表歉意。已自动禁用。",
        "moduleMigration.logFetchRemoteTweakFailed": "获取远程调整值失败",
        "moduleMigration.logLocalDatabaseNotReady": "出错了！本地数据库尚未准备好",
        "moduleMigration.logMigratedSameBehaviour": "已迁移到 db:${current},行为与之前相同",
        "moduleMigration.logMigrationFailed": "从 ${old} 到 ${current} 的迁移失败或已取消",
        "moduleMigration.logRedflag2CreationFail": "创建 redflag2 失败",
        "moduleMigration.logRemoteTweakUnavailable": "无法获取远程调整值",
        "moduleMigration.logSetupCancelled": "设置已取消,Self-hosted LiveSync 正在等待您的设置！",
        "moduleMigration.msgFetchRemoteAgain": "您可能已经知道,Self-hosted LiveSync 更改了其默认行为和数据库结构。\n\n值得庆幸的是,在您的时间和努力下,远程数据库似乎已经迁移完成。恭喜！\n\n但是,我们还需要一点点操作。此设备的配置与远程数据库不兼容。我们需要再次从远程数据库获取。我们现在应该再次从远程获取吗？\n\n___注意:在更改配置并再次获取数据库之前,我们无法进行同步。___\n___注意2:chunks 是完全不可变的,我们只能获取元数据和差异",
        "moduleMigration.msgInitialSetup": "您的设备**尚未设置**。让我引导您完成设置过程。\n\n请记住,每个对话框内容都可以复制到剪贴板。如果以后需要参考,可以将其粘贴到 Obsidian 的笔记中。您也可以使用翻译工具将其翻译成您的语言。\n\n首先,您有**设置 URI** 吗？\n\n注意:如果您不知道这是什么,请参阅[文档](${URI_DOC})",
        "moduleMigration.msgRecommendSetupUri": "我们强烈建议您生成一个设置 URI 并使用它。\n如果您对此不了解,请参阅[文档](${URI_DOC})(再次抱歉,但这很重要)。\n\n您想如何手动设置?",
        "moduleMigration.msgSinceV02321": "自 v0.23.21 起,Self-hosted LiveSync 更改了默认行为和数据库结构。进行了以下更改：\n\n1. **文件名的区分大小写** \n现在处理文件名时不区分大小写。这对于大多数平台来说是一个有益的更改,除了 Linux 和 iOS,它们不能有效地管理文件名的大小写敏感性。\n(在这些平台上,对于名称相同但大小写不同的文件将显示警告)。\n\n2. **chunks 的版本处理** \nchunks 是不可变的,这使得它们的版本可以固定。此更改将提高文件保存的性能。\n\n___然而,要启用这些更改中的任何一个,都需要重建远程和本地数据库。这个过程需要几分钟,我们建议您在有充足时间时进行。___\n\n- 如果您希望保持以前的行为,可以使用 `${KEEP}` 跳过此过程。\n- 如果您没有足够的时间,请选择 `${DISMISS}`。稍后会再次提示您。\n- 如果您已在另一台设备上重建了数据库,请选择 `${DISMISS}` 并尝试再次同步。由于检测到差异,系统会再次提示您",
        "moduleMigration.optionAdjustRemote": "调整到远程设置",
        "moduleMigration.optionDecideLater": "稍后决定",
        "moduleMigration.optionEnableBoth": "启用两者",
        "moduleMigration.optionEnableFilenameCaseInsensitive": "仅启用 #1",
        "moduleMigration.optionEnableFixedRevisionForChunks": "仅启用 #2",
        "moduleMigration.optionHaveSetupUri": "是的,我有",
        "moduleMigration.optionKeepPreviousBehaviour": "保持以前的行为",
        "moduleMigration.optionManualSetup": "全部手动设置",
        "moduleMigration.optionNoAskAgain": "不,请稍后再次询问",
        "moduleMigration.optionNoSetupUri": "不,我没有",
        "moduleMigration.optionRemindNextLaunch": "下次启动时提醒我",
        "moduleMigration.optionSetupViaP2P": "Use %{short_p2p_sync} to set up",
        "moduleMigration.optionSetupWizard": "带我进入设置向导",
        "moduleMigration.optionYesFetchAgain": "是的,再次获取",
        "moduleMigration.titleCaseSensitivity": "大小写敏感性",
        "moduleMigration.titleRecommendSetupUri": "推荐使用设置 URI",
        "moduleMigration.titleWelcome": "欢迎使用 Self-hosted LiveSync",
        "moduleObsidianMenu.replicate": "Replicate",
        "Move remotely deleted files to the trash, instead of deleting.": "将远程删除的文件移至回收站,而不是直接删除",
        "Not all messages have been translated. And, please revert to \"Default\" when reporting errors.": "并非所有消息都已翻译。请在报告错误时恢复为\"默认\"",
        "Notify all setting files": "通知所有设置文件",
        "Notify customized": "通知自定义设置",
        "Notify when other device has newly customized.": "当其他设备有新的自定义设置时通知 ",
        "Notify when the estimated remote storage size exceeds on start up": "启动时当估计的远程存储大小超出时通知",
        "Now we can choose how to split the chunks; V3 is the most efficient. If you have troubled, please make this Default or Legacy.": "现在我们可以选择如何分割数据块:V3是最高效的方案。若遇到问题,请将其设为默认值或使用旧版方案",
        "Number of batches to process at a time. Defaults to 40. Minimum is 2. This along with batch size controls how many docs are kept in memory at a time.": "一次处理的批量数量。默认为 40。最小为 2。此设置与批量大小一起控制一次在内存中保留多少文档",
        "Number of changes to sync at a time. Defaults to 50. Minimum is 2.": "一次同步的更改数量。默认为 50。最小为 2。",
        "obsidianLiveSyncSettingTab.btnApply": "应用",
        "obsidianLiveSyncSettingTab.btnCheck": "检查",
        "obsidianLiveSyncSettingTab.btnCopy": "复制",
        "obsidianLiveSyncSettingTab.btnDisable": "禁用",
        "obsidianLiveSyncSettingTab.btnDiscard": "丢弃",
        "obsidianLiveSyncSettingTab.btnEnable": "启用",
        "obsidianLiveSyncSettingTab.btnFix": "修复",
        "obsidianLiveSyncSettingTab.btnGotItAndUpdated": "我明白了并且已更新",
        "obsidianLiveSyncSettingTab.btnNext": "下一步",
        "obsidianLiveSyncSettingTab.btnStart": "开始",
        "obsidianLiveSyncSettingTab.btnTest": "测试",
        "obsidianLiveSyncSettingTab.btnUse": "使用",
        "obsidianLiveSyncSettingTab.buttonFetch": "获取",
        "obsidianLiveSyncSettingTab.buttonNext": "下一步",
        "obsidianLiveSyncSettingTab.defaultLanguage": "默认",
        "obsidianLiveSyncSettingTab.descConnectSetupURI": "这是使用设置 URI 设置 Self-hosted LiveSync 的推荐方法",
        "obsidianLiveSyncSettingTab.descCopySetupURI": "非常适合设置新设备！",
        "obsidianLiveSyncSettingTab.descEnableLiveSync": "仅在配置了上述两个选项之一或手动完成所有配置后启用此选项",
        "obsidianLiveSyncSettingTab.descFetchConfigFromRemote": "从已配置的远程服务器获取必要的设置",
        "obsidianLiveSyncSettingTab.descManualSetup": "不推荐,但如果您没有设置 URI 则很有用",
        "obsidianLiveSyncSettingTab.descTestDatabaseConnection": "打开数据库连接。如果未找到远程数据库并且您有创建数据库的权限,则将创建数据库",
        "obsidianLiveSyncSettingTab.descValidateDatabaseConfig": "检查并修复数据库配置中的任何潜在问题",
        "obsidianLiveSyncSettingTab.errAccessForbidden": "❗ 访问被禁止",
        "obsidianLiveSyncSettingTab.errCannotContinueTest": "我们无法继续测试。",
        "obsidianLiveSyncSettingTab.errCorsCredentials": "❗ cors.credentials 设置错误",
        "obsidianLiveSyncSettingTab.errCorsNotAllowingCredentials": "❗ CORS 不允许凭据",
        "obsidianLiveSyncSettingTab.errCorsOrigins": "❗ cors.origins 设置错误",
        "obsidianLiveSyncSettingTab.errEnableCors": "❗ httpd.enable_cors 设置错误",
        "obsidianLiveSyncSettingTab.errEnableCorsChttpd": "❗ chttpd.enable_cors is wrong",
        "obsidianLiveSyncSettingTab.errMaxDocumentSize": "❗ couchdb.max_document_size 设置过低)",
        "obsidianLiveSyncSettingTab.errMaxRequestSize": "❗ chttpd.max_http_request_size 设置过低)",
        "obsidianLiveSyncSettingTab.errMissingWwwAuth": "❗ 缺少 httpd.WWW-Authenticate 设置",
        "obsidianLiveSyncSettingTab.errRequireValidUser": "❗ chttpd.require_valid_user 设置错误",
        "obsidianLiveSyncSettingTab.errRequireValidUserAuth": "❗ chttpd_auth.require_valid_user 设置错误",
        "obsidianLiveSyncSettingTab.labelDisabled": "⏹️ : 已禁用",
        "obsidianLiveSyncSettingTab.labelEnabled": "🔁 : 已启用",
        "obsidianLiveSyncSettingTab.levelAdvanced": "(进阶)",
        "obsidianLiveSyncSettingTab.levelEdgeCase": "(边缘情况)",
        "obsidianLiveSyncSettingTab.levelPowerUser": "(高级用户)",
        "obsidianLiveSyncSettingTab.linkOpenInBrowser": "在浏览器中打开",
        "obsidianLiveSyncSettingTab.linkPageTop": "页面顶部",
        "obsidianLiveSyncSettingTab.linkTipsAndTroubleshooting": "提示和故障排除",
        "obsidianLiveSyncSettingTab.linkTroubleshooting": "/docs/troubleshooting.md",
        "obsidianLiveSyncSettingTab.logCannotUseCloudant": "此功能不能与 IBM Cloudant 一起使用 ",
        "obsidianLiveSyncSettingTab.logCheckingConfigDone": "配置检查完成",
        "obsidianLiveSyncSettingTab.logCheckingConfigFailed": "配置检查失败",
        "obsidianLiveSyncSettingTab.logCheckingDbConfig": "正在检查数据库配置",
        "obsidianLiveSyncSettingTab.logCheckPassphraseFailed": "错误：无法使用远程服务器检查密码：\n${db} ",
        "obsidianLiveSyncSettingTab.logConfiguredDisabled": "配置的同步模式：已禁用",
        "obsidianLiveSyncSettingTab.logConfiguredLiveSync": "配置的同步模式:LiveSync",
        "obsidianLiveSyncSettingTab.logConfiguredPeriodic": "配置的同步模式：定期",
        "obsidianLiveSyncSettingTab.logCouchDbConfigFail": "CouchDB 配置：${title} 失败",
        "obsidianLiveSyncSettingTab.logCouchDbConfigSet": "CouchDB 配置：${title} -> 设置 ${key} 为 ${value}",
        "obsidianLiveSyncSettingTab.logCouchDbConfigUpdated": "CouchDB 配置：${title} 成功更新",
        "obsidianLiveSyncSettingTab.logDatabaseConnected": "数据库已连接",
        "obsidianLiveSyncSettingTab.logEncryptionNoPassphrase": "没有密码无法启用加密",
        "obsidianLiveSyncSettingTab.logEncryptionNoSupport": "您的设备不支持加密 ",
        "obsidianLiveSyncSettingTab.logErrorOccurred": "发生错误！！",
        "obsidianLiveSyncSettingTab.logEstimatedSize": "估计大小：${size}",
        "obsidianLiveSyncSettingTab.logPassphraseInvalid": "密码无效,请修正",
        "obsidianLiveSyncSettingTab.logPassphraseNotCompatible": "错误：密码与远程服务器不兼容！请再次检查！",
        "obsidianLiveSyncSettingTab.logRebuildNote": "同步已禁用,如果需要,请获取并重新启用",
        "obsidianLiveSyncSettingTab.logSelectAnyPreset": "选择任何预设",
        "obsidianLiveSyncSettingTab.msgAreYouSureProceed": "您确定要继续吗？",
        "obsidianLiveSyncSettingTab.msgChangesNeedToBeApplied": "需要应用更改！",
        "obsidianLiveSyncSettingTab.msgConfigCheck": "--配置检查--",
        "obsidianLiveSyncSettingTab.msgConfigCheckFailed": "配置检查失败。您仍要继续吗？",
        "obsidianLiveSyncSettingTab.msgConnectionCheck": "--连接检查--",
        "obsidianLiveSyncSettingTab.msgConnectionProxyNote": "如果您在连接检查时遇到问题(即使检查了配置后),请检查您的反向代理配置",
        "obsidianLiveSyncSettingTab.msgCurrentOrigin": "当前源: {origin}",
        "obsidianLiveSyncSettingTab.msgDiscardConfirmation": "您真的要丢弃现有的设置和数据库吗？",
        "obsidianLiveSyncSettingTab.msgDone": "--完成--",
        "obsidianLiveSyncSettingTab.msgEnableCors": "设置 httpd.enable_cors",
        "obsidianLiveSyncSettingTab.msgEnableEncryptionRecommendation": "我们建议启用端到端加密和路径混淆。您确定要在没有加密的情况下继续吗？",
        "obsidianLiveSyncSettingTab.msgFetchConfigFromRemote": "您想从远程服务器获取配置吗？",
        "obsidianLiveSyncSettingTab.msgGenerateSetupURI": "全部完成！您想生成一个设置 URI 来设置其他设备吗？",
        "obsidianLiveSyncSettingTab.msgIfConfigNotPersistent": "如果服务器配置不是持久的(例如,在 docker 上运行),此处的值可能会更改。一旦能够连接,请更新服务器 local.ini 中的设置",
        "obsidianLiveSyncSettingTab.msgInvalidPassphrase": "您的加密密码可能无效。您确定要继续吗？",
        "obsidianLiveSyncSettingTab.msgNewVersionNote": "因为升级通知来到这里？请查看版本历史。如果您满意,请点击按钮。新的更新将再次提示此信息",
        "obsidianLiveSyncSettingTab.msgNonHTTPSInfo": "配置为非 HTTPS URI。请注意,这可能在移动设备上无法工作",
        "obsidianLiveSyncSettingTab.msgNonHTTPSWarning": "无法连接到非 HTTPS URI。请更新您的配置并重试",
        "obsidianLiveSyncSettingTab.msgNotice": "---注意---",
        "obsidianLiveSyncSettingTab.msgObjectStorageWarning": "警告：此功能仍在开发中,请注意以下几点：\n- 仅追加架构。需要重建才能缩小存储空间。\n- 有点脆弱。\n- 首次同步时,所有历史记录将从远程传输。注意数据上限和慢速。\n- 只有差异会实时同步。\n\n如果您遇到任何问题,或对此功能有任何想法,请在 GitHub 上创建 issue。\n感谢您的巨大贡献",
        "obsidianLiveSyncSettingTab.msgOriginCheck": "源检查: {org}",
        "obsidianLiveSyncSettingTab.msgRebuildRequired": "需要重建数据库以应用更改。请选择应用更改的方法。\n\n<details>\n<summary>图例</summary>\n\n| 符号 | 含义 |\n|: ------ :| ------- |\n| ⇔ | 最新 |\n| ⇄ | 同步以平衡 |\n| ⇐,⇒ | 传输以覆盖 |\n| ⇠,⇢ | 从另一侧传输以覆盖 |\n\n</details>\n\n## ${OPTION_REBUILD_BOTH}\n概览:📄 ⇒¹ 💻 ⇒² 🛰️ ⇢ⁿ 💻 ⇄ⁿ⁺¹ 📄\n使用此设备的现有文件重建本地和远程数据库。\n这将导致其他设备被锁定,并且它们需要执行获取操作。\n## ${OPTION_FETCH}\n概览:📄 ⇄² 💻 ⇐¹ 🛰️ ⇔ 💻 ⇔ 📄\n初始化本地数据库并使用从远程数据库获取的数据重建它。\n这种情况包括您已经重建了远程数据库的情况。\n## ${OPTION_ONLY_SETTING}\n仅存储设置。**注意：这可能导致数据损坏**；通常需要重建数据库",
        "obsidianLiveSyncSettingTab.msgSelectAndApplyPreset": "请选择并应用任何预设项以完成向导",
        "obsidianLiveSyncSettingTab.msgSetCorsCredentials": "设置 cors.credentials",
        "obsidianLiveSyncSettingTab.msgSetCorsOrigins": "设置 cors.origins",
        "obsidianLiveSyncSettingTab.msgSetMaxDocSize": "设置 couchdb.max_document_size",
        "obsidianLiveSyncSettingTab.msgSetMaxRequestSize": "设置 chttpd.max_http_request_size",
        "obsidianLiveSyncSettingTab.msgSetRequireValidUser": "设置 chttpd.require_valid_user = true",
        "obsidianLiveSyncSettingTab.msgSetRequireValidUserAuth": "设置 chttpd_auth.require_valid_user = true",
        "obsidianLiveSyncSettingTab.msgSettingModified": "设置 \"${setting}\" 已从另一台设备修改。点击 {HERE} 重新加载设置。点击其他地方忽略更改",
        "obsidianLiveSyncSettingTab.msgSettingsUnchangeableDuringSync": "这些设置在同步期间无法更改。请在“同步设置”中禁用所有同步以解锁",
        "obsidianLiveSyncSettingTab.msgSetWwwAuth": "设置 httpd.WWW-Authenticate",
        "obsidianLiveSyncSettingTab.nameApplySettings": "应用设置",
        "obsidianLiveSyncSettingTab.nameConnectSetupURI": "使用设置 URI 连接",
        "obsidianLiveSyncSettingTab.nameCopySetupURI": "将当前设置复制为设置 URI",
        "obsidianLiveSyncSettingTab.nameDisableHiddenFileSync": "禁用隐藏文件同步",
        "obsidianLiveSyncSettingTab.nameDiscardSettings": "丢弃现有设置和数据库",
        "obsidianLiveSyncSettingTab.nameEnableHiddenFileSync": "启用隐藏文件同步",
        "obsidianLiveSyncSettingTab.nameEnableLiveSync": "启用 LiveSync",
        "obsidianLiveSyncSettingTab.nameHiddenFileSynchronization": "隐藏文件同步",
        "obsidianLiveSyncSettingTab.nameManualSetup": "手动设置",
        "obsidianLiveSyncSettingTab.nameTestConnection": "测试连接",
        "obsidianLiveSyncSettingTab.nameTestDatabaseConnection": "测试数据库连接",
        "obsidianLiveSyncSettingTab.nameValidateDatabaseConfig": "验证数据库配置",
        "obsidianLiveSyncSettingTab.okAdminPrivileges": "✔ 您拥有管理员权限",
        "obsidianLiveSyncSettingTab.okCorsCredentials": "✔ cors.credentials 设置正确",
        "obsidianLiveSyncSettingTab.okCorsCredentialsForOrigin": "CORS 凭据正常",
        "obsidianLiveSyncSettingTab.okCorsOriginMatched": "✔ CORS 源正常",
        "obsidianLiveSyncSettingTab.okCorsOrigins": "✔ cors.origins 设置正确",
        "obsidianLiveSyncSettingTab.okEnableCors": "✔ httpd.enable_cors 设置正确",
        "obsidianLiveSyncSettingTab.okEnableCorsChttpd": "✔ chttpd.enable_cors is ok.",
        "obsidianLiveSyncSettingTab.okMaxDocumentSize": "✔ couchdb.max_document_size 设置正确",
        "obsidianLiveSyncSettingTab.okMaxRequestSize": "✔ chttpd.max_http_request_size 设置正确",
        "obsidianLiveSyncSettingTab.okRequireValidUser": "✔ chttpd.require_valid_user 设置正确",
        "obsidianLiveSyncSettingTab.okRequireValidUserAuth": "✔ chttpd_auth.require_valid_user 设置正确",
        "obsidianLiveSyncSettingTab.okWwwAuth": "✔ httpd.WWW-Authenticate 设置正确",
        "obsidianLiveSyncSettingTab.optionApply": "应用",
        "obsidianLiveSyncSettingTab.optionCancel": "取消",
        "obsidianLiveSyncSettingTab.optionCouchDB": "CouchDB",
        "obsidianLiveSyncSettingTab.optionDisableAllAutomatic": "禁用所有自动同步",
        "obsidianLiveSyncSettingTab.optionFetchFromRemote": "从远程获取",
        "obsidianLiveSyncSettingTab.optionHere": "这里",
        "obsidianLiveSyncSettingTab.optionLiveSync": "LiveSync",
        "obsidianLiveSyncSettingTab.optionMinioS3R2": "Minio, S3, R2",
        "obsidianLiveSyncSettingTab.optionOkReadEverything": "好的,我已经阅读了所有内容 ",
        "obsidianLiveSyncSettingTab.optionOnEvents": "基于事件",
        "obsidianLiveSyncSettingTab.optionPeriodicAndEvents": "定期和基于事件",
        "obsidianLiveSyncSettingTab.optionPeriodicWithBatch": "定期与批量",
        "obsidianLiveSyncSettingTab.optionRebuildBoth": "从此设备重建两者",
        "obsidianLiveSyncSettingTab.optionSaveOnlySettings": "(危险)仅保存设置",
        "obsidianLiveSyncSettingTab.panelChangeLog": "更新日志",
        "obsidianLiveSyncSettingTab.panelGeneralSettings": "常规设置",
        "obsidianLiveSyncSettingTab.panelPrivacyEncryption": "隐私与加密",
        "obsidianLiveSyncSettingTab.panelRemoteConfiguration": "远程配置",
        "obsidianLiveSyncSettingTab.panelSetup": "设置",
        "obsidianLiveSyncSettingTab.serverVersion": "Server info: ${info}",
        "obsidianLiveSyncSettingTab.titleAppearance": "外观",
        "obsidianLiveSyncSettingTab.titleConflictResolution": "冲突解决",
        "obsidianLiveSyncSettingTab.titleCongratulations": "恭喜！",
        "obsidianLiveSyncSettingTab.titleCouchDB": "CouchDB",
        "obsidianLiveSyncSettingTab.titleDeletionPropagation": "删除传播",
        "obsidianLiveSyncSettingTab.titleEncryptionNotEnabled": "未启用加密",
        "obsidianLiveSyncSettingTab.titleEncryptionPassphraseInvalid": "加密密码无效",
        "obsidianLiveSyncSettingTab.titleExtraFeatures": "启用额外和高级功能",
        "obsidianLiveSyncSettingTab.titleFetchConfig": "获取配置",
        "obsidianLiveSyncSettingTab.titleFetchConfigFromRemote": "从远程服务器获取配置",
        "obsidianLiveSyncSettingTab.titleFetchSettings": "获取设置",
        "obsidianLiveSyncSettingTab.titleHiddenFiles": "隐藏文件",
        "obsidianLiveSyncSettingTab.titleLogging": "日志记录",
        "obsidianLiveSyncSettingTab.titleMinioS3R2": "Minio, S3, R2",
        "obsidianLiveSyncSettingTab.titleNotification": "通知",
        "obsidianLiveSyncSettingTab.titleOnlineTips": "在线提示",
        "obsidianLiveSyncSettingTab.titleQuickSetup": "快速设置",
        "obsidianLiveSyncSettingTab.titleRebuildRequired": "需要重建",
        "obsidianLiveSyncSettingTab.titleRemoteConfigCheckFailed": "远程配置检查失败",
        "obsidianLiveSyncSettingTab.titleRemoteServer": "远程服务器",
        "obsidianLiveSyncSettingTab.titleReset": "重置",
        "obsidianLiveSyncSettingTab.titleSetupOtherDevices": "设置其他设备",
        "obsidianLiveSyncSettingTab.titleSynchronizationMethod": "同步方法",
        "obsidianLiveSyncSettingTab.titleSynchronizationPreset": "同步预设",
        "obsidianLiveSyncSettingTab.titleSyncSettings": "同步设置",
        "obsidianLiveSyncSettingTab.titleSyncSettingsViaMarkdown": "通过 Markdown 同步设置",
        "obsidianLiveSyncSettingTab.titleUpdateThinning": "更新频率限制",
        "obsidianLiveSyncSettingTab.warnCorsOriginUnmatched": "⚠ CORS 源不匹配 {from}->{to}",
        "obsidianLiveSyncSettingTab.warnNoAdmin": "⚠ 您没有管理员权限",
        "P2P.AskPassphraseForDecrypt": "The remote peer shared the configuration. Please input the passphrase to decrypt the configuration.",
        "P2P.AskPassphraseForShare": "The remote peer requested this device configuration. Please input the passphrase to share the configuration. You can ignore the request by cancelling this dialogue.",
        "P2P.DisabledButNeed": "%{title_p2p_sync} is disabled. Do you really want to enable it?",
        "P2P.FailedToOpen": "Failed to open P2P connection to the signaling server.",
        "P2P.NoAutoSyncPeers": "No auto-sync peers found. Please set peers on the %{long_p2p_sync} pane.",
        "P2P.NoKnownPeers": "No peers has been detected, waiting incoming other peers...",
        "P2P.Note.description": " This replicator allows us to synchronise our vault with other devices\nusing a peer-to-peer connection. We can        use this to synchronise our vault with our other devices without using a cloud service.\nThis replicator is based on Trystero. It also uses a signaling server to establish a connection between devices. The signaling server is used to exchange connection information between devices. It does (or,should) not know or store any of our data.\n\nThe signaling server can be hosted by anyone. This is just a Nostr relay. For the sake of simplicity and checking the behaviour of the replicator, an instance of the signaling server is hosted by vrtmrz. You can use the experimental server provided by vrtmrz, or you can use any other server.\n\nBy the way, even if the signaling server does not store our data, it can see the connection information of some of our devices. Please be aware of this. Also, be cautious when using the server provided by someone else.",
        "P2P.Note.important_note": "The Experimental Implementation of the Peer-to-Peer Replicator.",
        "P2P.Note.important_note_sub": "This feature is still in the experimental stage. Please be aware that this feature may not work as expected. Furthermore, it may have some bugs, security issues, and other issues. Please use this feature at your own risk. Please contribute to the development of this feature.",
        "P2P.Note.Summary": "What is this  feature? (and some important notes, please read once)",
        "P2P.NotEnabled": "%{title_p2p_sync} is not enabled. We cannot open a new connection.",
        "P2P.P2PReplication": "%{P2P} Replication",
        "P2P.PaneTitle": "%{long_p2p_sync}",
        "P2P.ReplicatorInstanceMissing": "P2P Sync replicator is not found, possibly not have been configured or enabled.",
        "P2P.SeemsOffline": "Peer ${name} seems offline, skipped.",
        "P2P.SyncAlreadyRunning": "P2P Sync is already running.",
        "P2P.SyncCompleted": "P2P Sync completed.",
        "P2P.SyncStartedWith": "P2P Sync with ${name} have been started.",
        "Passphrase": "密码",
        "Passphrase of sensitive configuration items": "敏感配置项的密码",
        "password": "密码",
        "Password": "密码",
        "Path Obfuscation": "路径混淆",
        "Per-file-saved customization sync": "按文件保存的自定义同步",
        "Periodic Sync interval": "定期同步间隔",
        "Please use V2, V1 is deprecated and will be removed in the future, It was not a very appropriate algorithm. Only for compatibility V1 is kept.": "请使用V2版本,V1版本已弃用并将被移除,该算法并不十分合适。仅出于兼容性考虑保留V1版本",
        "Presets": "预设",
        "Property Encryption": "属性加密",
        "Process small files in the foreground": "在前台处理小文件",
        "Process files even if seems to be corrupted": "即使文件看似已损坏也进行处理",
        "RedFlag.Fetch.Method.Desc": "How do you want to fetch?\n- %{RedFlag.Fetch.Method.FetchSafer}.\n  **Low Traffic**, **High CPU**, **Low Risk**\n  Recommended if ...\n  - Files possibly inconsistent\n  - Files were not so much\n- %{RedFlag.Fetch.Method.FetchSmoother}.\n  **Low Traffic**, **Moderate CPU**, **Low to Moderate Risk**\n  Recommended if ...\n  - Files probably consistent\n  - You have a lot of files.\n- %{RedFlag.Fetch.Method.FetchTraditional}.\n  **High Traffic**, **Low CPU**, **Low to Moderate Risk**\n\n>[!INFO]- Details\n> ## %{RedFlag.Fetch.Method.FetchSafer}.\n> **Low Traffic**, **High CPU**, **Low Risk**\n> This option first creates a local database using existing local files before fetching data from the remote source.\n> If matching files exist both locally and remotely, only the differences between them will be transferred.\n> However, files present in both locations will initially be handled as conflicted files. They will be resolved automatically if they are not actually conflicted, but this process may take time.\n> This is generally the safest method, minimizing data loss risk.\n> ## %{RedFlag.Fetch.Method.FetchSmoother}.\n> **Low Traffic**, **Moderate CPU**, **Low to Moderate Risk** (depending operation)\n> This option first creates chunks from local files for the database, then fetches data. Consequently, only chunks missing locally are transferred. However, all metadata is taken from the remote source.\n> Local files are then compared against this metadata at launch. The content considered newer will overwrite the older one (by modified time). This outcome is then synchronised back to the remote database.\n> This is generally safe if local files are genuinely the latest timestamp. However, it can cause problems if a file has a newer timestamp but older content (like the initial `welcome.md`).\n> This uses less CPU and faster than \"%{RedFlag.Fetch.Method.FetchSafer}\", but it may lead to data loss if not used carefully.\n> ## %{RedFlag.Fetch.Method.FetchTraditional}.\n> **High Traffic**, **Low CPU**, **Low to Moderate Risk** (depending operation)\n> All things will be fetched from the remote.\n> Similar to the %{RedFlag.Fetch.Method.FetchSmoother}, but all chunks are fetched from the remote source.\n> This is the most traditional way to fetch, typically consuming the most network traffic and time. It also carries a similar risk of overwriting remote files to the '%{RedFlag.Fetch.Method.FetchSmoother}' option.\n> However, it is often considered the most stable method because it is the longest-established and most straightforward approach.",
        "RedFlag.Fetch.Method.FetchSafer": "Create a local database once before fetching",
        "RedFlag.Fetch.Method.FetchSmoother": "Create local file chunks before fetching",
        "RedFlag.Fetch.Method.FetchTraditional": "Fetch everything from the remote",
        "RedFlag.Fetch.Method.Title": "How do you want to fetch?",
        "RedFlag.FetchRemoteConfig.Buttons.Cancel": "No, use local settings",
        "RedFlag.FetchRemoteConfig.Buttons.Fetch": "Yes, fetch and apply remote settings",
        "RedFlag.FetchRemoteConfig.Message": "Do you want to fetch and apply remotely stored preference settings to the device?",
        "RedFlag.FetchRemoteConfig.Title": "Fetch Remote Configuration",
        "Reducing the frequency with which on-disk changes are reflected into the DB": "降低将磁盘上的更改反映到数据库中的频率",
        "Region": "区域",
        "Rotation Duration": "轮换时长",
        "Remote server type": "远程服务器类型",
        "Remote Type": "远程类型",
        "Replicator.Dialogue.Locked.Action.Dismiss": "Cancel for reconfirmation",
        "Replicator.Dialogue.Locked.Action.Fetch": "Fetch all from the remote database again",
        "Replicator.Dialogue.Locked.Action.Unlock": "Unlock the remote database",
        "Replicator.Dialogue.Locked.Message": "Remote database is locked. This is due to a rebuild on one of the terminals.\nThe device is therefore asked to withhold the connection to avoid database corruption.\n\nThere are three options that we can do:\n\n- %{Replicator.Dialogue.Locked.Action.Fetch}\n  The most preferred and reliable way. This will dispose the local database once, and fetch all from the remote database again, In most case, we can perform this safely. However, it takes some time and should be done in stable network.\n- %{Replicator.Dialogue.Locked.Action.Unlock}\n  This method can only be used if we are already reliably synchronised by other replication methods. This does not simply mean that we have the same files. If you are not sure, you should avoid it.\n- %{Replicator.Dialogue.Locked.Action.Dismiss}\n    This will cancel the operation. And we will asked again on next request.\n",
        "Replicator.Dialogue.Locked.Message.Fetch": "Fetch all has been scheduled. Plug-in will be restarted to perform it.",
        "Replicator.Dialogue.Locked.Message.Unlocked": "The remote database has been unlocked. Please retry the operation.",
        "Replicator.Dialogue.Locked.Title": "Locked",
        "Replicator.Message.Cleaned": "Database cleaning up is in process. replication has been cancelled",
        "Replicator.Message.InitialiseFatalError": "No replicator is available, this is the fatal error.",
        "Replicator.Message.Pending": "Some file events are pending. Replication has been cancelled.",
        "Replicator.Message.SomeModuleFailed": "Replication has been cancelled by some module failure",
        "Replicator.Message.VersionUpFlash": "An update has been detected. Please open the Settings dialogue and check the Change Log. Replication has been cancelled.",
        "Requires restart of Obsidian": "需要重启 Obsidian",
        "Requires restart of Obsidian.": "需要重启 Obsidian ",
        "Save settings to a markdown file. You will be notified when new settings arrive. You can set different files by the platform.": "将设置保存到一个 Markdown 文件中。当新设置到达时,您将收到通知。您可以根据平台设置不同的文件 ",
        "Saving will be performed forcefully after this number of seconds.": "在此秒数后将强制执行保存 ",
        "Scan changes on customization sync": "在自定义同步时扫描更改",
        "Scan customization automatically": "自动扫描自定义设置",
        "Scan customization before replicating.": "在复制前扫描自定义设置 ",
        "Scan customization every 1 minute.": "每1分钟扫描自定义设置 ",
        "Scan customization periodically": "定期扫描自定义设置",
        "Scan for hidden files before replication": "复制前扫描隐藏文件",
        "Scan hidden files periodically": "定期扫描隐藏文件",
        "Seconds, 0 to disable": "秒,0为禁用",
        "Seconds. Saving to the local database will be delayed until this value after we stop typing or saving.": "秒。在我们停止输入或保存后,保存到本地数据库将延迟此值 ",
        "Secret Key": "Secret Key",
        "Server URI": "服务器 URI",
        "Setting.GenerateKeyPair.Desc": "We have generated a key pair!\n\nNote: This key pair will never be shown again. Please save it in a safe place. If you have lost it, you need to generate a new key pair.\nNote 2: The public key is in spki format, and the Private key is in pkcs8 format. For the sake of convenience, newlines are converted to `\\n` in public key.\nNote 3: The public key should be configured in the remote database, and the private key should be configured in local devices.\n\n>[!FOR YOUR EYES ONLY]-\n> <div class=\"sls-keypair\">\n>\n> ### Public Key\n> ```\n${public_key}\n> ```\n>\n> ### Private Key\n> ```\n${private_key}\n> ```\n>\n> </div>\n\n>[!Both for copying]-\n>\n> <div class=\"sls-keypair\">\n>\n> ```\n${public_key}\n${private_key}\n> ```\n>\n> </div>\n\n",
        "Setting.GenerateKeyPair.Title": "New key pair has been generated!",
        "Setting.TroubleShooting": "故障排除",
        "Setting.TroubleShooting.Doctor": "自动诊断",
        "Setting.TroubleShooting.Doctor.Desc": "检测到非最佳设置(与迁移期间相同)",
        "Setting.TroubleShooting.ScanBrokenFiles": "扫描损坏的文件",
        "Setting.TroubleShooting.ScanBrokenFiles.Desc": "扫描数据库中未正确存储的文件",
        "SettingTab.Message.AskRebuild": "Your changes require fetching from the remote database. Do you want to proceed?",
        "Setup.Apply.Buttons.ApplyAndFetch": "Apply and Fetch",
        "Setup.Apply.Buttons.ApplyAndMerge": "Apply and Merge",
        "Setup.Apply.Buttons.ApplyAndRebuild": "Apply and Rebuild",
        "Setup.Apply.Buttons.Cancel": "Discard and Cancel",
        "Setup.Apply.Buttons.OnlyApply": "Only Apply",
        "Setup.Apply.Message": "The new configuration is ready. Let us proceed to apply it.\nThere are several ways to apply this:\n\n- Apply and Fetch\n  Configure this device as a new client. After applying, synchronise from the remote server.\n- Apply and Merge\n  Configure on a device that already has the file. It processes the local files and transfers the differences. Conflicts may arise.\n- Apply and Rebuild\n  Rebuild the remote using local files. This is typically done if the server becomes corrupted or we wish to start from scratch.\n  Other devices will be locked and required to re-fetch.\n- Only Apply\n  Apply only. Conflicts may arise if a rebuild is required.",
        "Setup.Apply.Title": "Apply new configuration from the ${method}",
        "Setup.Apply.WarningRebuildRecommended": "NOTE: after adjusting the settings, it has been determined that a rebuild is required; Just Import is not recommended.",
        "Setup.Doctor.Buttons.No": "No, please use the settings in the URI as is",
        "Setup.Doctor.Buttons.Yes": "Yes, please consult the doctor",
        "Setup.Doctor.Message": "Self-hosted LiveSync has gradually become longer in history and some recommended settings have changed.\n\nNow, setup is a very good time to do this.\n\nDo you want to run Doctor to check if the imported settings are optimal compared to the latest state?",
        "Setup.Doctor.Title": "Do you want to consult the doctor?",
        "Setup.FetchRemoteConf.Buttons.Fetch": "Yes, please fetch the configuration",
        "Setup.FetchRemoteConf.Buttons.Skip": "No, please use the settings in the URI",
        "Setup.FetchRemoteConf.Message": "If we have already synchronised once with another device, the remote database stores the suitable configuration values between the synchronised devices. The plug-in would like to retrieve them for robust configuration.\n\nHowever, we have to make sure the one thing. Are we currently in a situation where we can access the network safely and retrieve the settings?\n\nNote: Mostly, you are safe to do this, that your remote database is hosted with a SSL certificate, and your network is not compromised.",
        "Setup.FetchRemoteConf.Title": "Fetch configuration from remote database?",
        "Setup.QRCode": "We have generated a QR code to transfer the settings. Please scan the QR code with your phone or other device.\nNote: The QR code is not encrypted, so be careful to open this.\n\n>[!FOR YOUR EYES ONLY]-\n> <div class=\"sls-qr\">${qr_image}</div>",
        "Setup.ShowQRCode": "使用QR码",
        "Setup.ShowQRCode.Desc": "使用QR码来传递配置",
        "Should we keep folders that don't have any files inside?": "我们是否应该保留内部没有任何文件的文件夹？",
        "Should we only check for conflicts when a file is opened?": "我们是否应该仅在文件打开时检查冲突？",
        "Should we prompt you about conflicting files when a file is opened?": "当文件打开时,是否提示冲突文件？",
        "Should we prompt you for every single merge, even if we can safely merge automatcially?": "即使我们可以安全地自动合并,是否也应该为每一次合并提示您？",
        "Show only notifications": "仅显示通知",
        "Show status as icons only": "仅以图标显示状态",
        "Show status inside the editor": "在编辑器内显示状态",
        "Show status on the status bar": "在状态栏上显示状态",
        "Show verbose log. Please enable if you report an issue.": "显示详细日志。如果您报告问题,请启用此选项 ",
        "Show status icon instead of file warnings banner": "显示状态图标而非文件警告横幅",
        "Starts synchronisation when a file is saved.": "当文件保存时启动同步 ",
        "Stop reflecting database changes to storage files.": "停止将数据库更改反映到存储文件 ",
        "Stop watching for file changes.": "停止监视文件更改 ",
        "Suppress notification of hidden files change": "抑制隐藏文件更改的通知",
        "Suspend database reflecting": "暂停数据库反映",
        "Suspend file watching": "暂停文件监视",
        "Subject (whoami)": "主题(我是谁)",
        "Sync after merging file": "合并文件后同步",
        "Sync automatically after merging files": "合并文件后自动同步",
        "Sync Mode": "同步模式",
        "Sync on Editor Save": "编辑器保存时同步",
        "Sync on File Open": "打开文件时同步",
        "Sync on Save": "保存时同步",
        "Sync on Startup": "启动时同步",
        "Testing only - Resolve file conflicts by syncing newer copies of the file, this can overwrite modified files. Be Warned.": "仅供测试 - 通过同步文件的较新副本来解决文件冲突,这可能会覆盖修改过的文件。请注意 ",
        "The delay for consecutive on-demand fetches": "连续按需获取的延迟",
        "The Hash algorithm for chunk IDs": "块 ID 的哈希算法(实验性)",
        "The maximum duration for which chunks can be incubated within the document. Chunks exceeding this period will graduate to independent chunks.": "文档中可以孵化的数据块的最大持续时间。超过此时间的数据块将成为独立数据块 ",
        "The maximum number of chunks that can be incubated within the document. Chunks exceeding this number will immediately graduate to independent chunks.": "文档中可以孵化的数据块的最大数量。超过此数量的数据块将立即成为独立数据块 ",
        "The maximum total size of chunks that can be incubated within the document. Chunks exceeding this size will immediately graduate to independent chunks.": "文档中可以孵化的数据块的最大总大小。超过此大小的数据块将立即成为独立数据块 ",
        "The key ID. this should be matched with CouchDB->jwt_keys->ALG:_`kid`.": "Key ID 应与CouchDB->jwt_keys->ALG:_`kid`匹配",
        "The subject for JWT authentication. Mostly username.": "JWT认证的主题。通常为用户名",
        "The Rotation duration of token in minutes. Each generated tokens will be valid only within this duration.": "Toekn的轮换时长(以分钟为单位)。每个生成的Token仅在此时长内有效",
        "The algorithm used for JWT authentication.": "用于JWT认证的算法",
        "This passphrase will not be copied to another device. It will be set to `Default` until you configure it again.": "此密码不会复制到另一台设备。在您再次配置之前,它将设置为 `Default` ",
        "TweakMismatchResolve.Action.Dismiss": "Dismiss",
        "TweakMismatchResolve.Action.UseConfigured": "Use configured settings",
        "TweakMismatchResolve.Action.UseMine": "Update remote database settings",
        "TweakMismatchResolve.Action.UseMineAcceptIncompatible": "Update remote database settings but keep as is",
        "TweakMismatchResolve.Action.UseMineWithRebuild": "Update remote database settings and rebuild again",
        "TweakMismatchResolve.Action.UseRemote": "Apply settings to this device",
        "TweakMismatchResolve.Action.UseRemoteAcceptIncompatible": "Apply settings to this device, but and ignore incompatibility",
        "TweakMismatchResolve.Action.UseRemoteWithRebuild": "Apply settings to this device, and fetch again",
        "TweakMismatchResolve.Message.Main": "\nThe settings in the remote database are as follows. These values are configured by other devices, which are synchronised with this device at least once.\n\nIf you want to use these settings, please select %{TweakMismatchResolve.Action.UseConfigured}.\nIf you want to keep the settings of this device, please select %{TweakMismatchResolve.Action.Dismiss}.\n\n${table}\n\n>[!TIP]\n> If you want to synchronise all settings, please use `Sync settings via markdown` after applying minimal configuration with this feature.\n\n${additionalMessage}",
        "TweakMismatchResolve.Message.MainTweakResolving": "Your configuration has not been matched with the one on the remote server.\n\nFollowing configuration should be matched:\n\n${table}\n\nLet us know your decision.\n\n${additionalMessage}",
        "TweakMismatchResolve.Message.UseRemote.WarningRebuildRecommended": "\n>[!NOTICE]\n> Some changes are compatible but may consume extra storage and transfer volumes. A rebuild is recommended. However, a rebuild may not be performed at present, but may be implemented in future maintenance.\n> ***Please ensure that you have time and are connected to a stable network to apply!***",
        "TweakMismatchResolve.Message.UseRemote.WarningRebuildRequired": "\n>[!WARNING]\n> Some remote configurations are not compatible with the local database of this device. Rebuilding the local database will be required.\n> ***Please ensure that you have time and are connected to a stable network to apply!***",
        "TweakMismatchResolve.Message.WarningIncompatibleRebuildRecommended": "\n>[!NOTICE]\n> We have detected that some of the values are different to make incompatible the local database with the remote database.\n> Some changes are compatible but may consume extra storage and transfer volumes. A rebuild is recommended. However, a rebuild may not be performed at present, but may be implemented in future maintenance.\n> If you want to rebuild, it takes a few minutes or more. **Make sure it is safe to perform it now.**",
        "TweakMismatchResolve.Message.WarningIncompatibleRebuildRequired": "\n>[!WARNING]\n> We have detected that some of the values are different to make incompatible the local database with the remote database.\n> Either local or remote rebuilds are required. Both of them takes a few minutes or more. **Make sure it is safe to perform it now.**",
        "TweakMismatchResolve.Table": "| Value name | This device | On Remote |\n|: --- |: ---- :|: ---- :|\n${rows}\n\n",
        "TweakMismatchResolve.Table.Row": "| ${name} | ${self} | ${remote} |",
        "TweakMismatchResolve.Title": "Configuration Mismatch Detected",
        "TweakMismatchResolve.Title.TweakResolving": "Configuration Mismatch Detected",
        "TweakMismatchResolve.Title.UseRemoteConfig": "Use Remote Configuration",
        "Unique name between all synchronized devices. To edit this setting, please disable customization sync once.": "所有同步设备之间的唯一名称。要编辑此设置,请首先禁用自定义同步",
        "Use Custom HTTP Handler": "使用自定义 HTTP 处理程序",
        "The key (PSK in HSxxx in base64, or private key in ESxxx in PEM) used for JWT authentication.": "用于JWT认证的密钥(HSxxx中的PSK采用base64编码,或ESxxx中的私钥采用PEM格式)",
        "Use dynamic iteration count": "使用动态迭代次数",
        "Use Segmented-splitter": "使用分段分割器",
        "Use splitting-limit-capped chunk splitter": "使用分割限制上限的块分割器",
        "Use the trash bin": "使用回收站",
        "Use timeouts instead of heartbeats": "使用超时而不是心跳",
        "Use JWT instead of Basic Authentication": "使用JWT替代基本认证",
        "username": "用户名",
        "Username": "用户名",
        "Use Request API to avoid `inevitable` CORS problem": "使用请求API来规避'不可避免'的跨域资源共享(CORS)问题",
        "Verbose Log": "详细日志",
        "Warning! This will have a serious impact on performance. And the logs will not be synchronised under the default name. Please be careful with logs; they often contain your confidential information.": "警告！这将严重影响性能。并且日志不会以默认名称同步。请小心处理日志；它们通常包含您的敏感信息 ",
        "When you save a file in the editor, start a sync automatically": "当您在编辑器中保存文件时,自动开始同步",
        "While enabled, it causes very performance impact but debugging replication testing and other features will be enabled. Please disable this if you have not read the source code. Requires restart of Obsidian.": "启用时会显著影响性能,但可启用复制、测试、调试及其他功能。若未阅读源代码,请禁用此功能。需重启Obsidian",
        "Write credentials in the file": "将凭据写入文件",
        "Write logs into the file": "将日志写入文件",
        "You can enable this setting to process the files with size mismatches, these files can be created by some APIs or integrations.": "您可以启用此设置来处理大小不匹配的文件,这些文件可能由某些API或集成程序创建"
    }
} as const;
