import qrcode from "qrcode-generator";
import { configURIBase, configURIBaseQR } from "../../../common/types";
import { decodeAnyArray, encodeAnyArray } from "../../../common/utils";
import { DEFAULT_SETTINGS, KeyIndexOfSettings, LOG_LEVEL_NOTICE, type ObsidianLiveSyncSettings } from "../common/types";
import { decryptString, encryptString } from "../encryption/stringEncryption";
import { LOG_LEVEL_VERBOSE, Logger } from "octagonal-wheels/common/logger";

/**
 * Encode settings to a tiny array to encode in QRCode,
 * Due to size limitation of QR code, we encode settings as an array instead of object.
 * @param settings settings to encode
 */
export function encodeSettingsToQRCodeData(settings: ObsidianLiveSyncSettings) {
    const settingArr = [];
    const fullIndexes = Object.entries(KeyIndexOfSettings) as [keyof ObsidianLiveSyncSettings, number][];
    for (const [settingKey, index] of fullIndexes) {
        const settingValue = settings[settingKey];
        if (index < 0) {
            // This setting should be ignored.
            continue;
        }
        settingArr[index] = settingValue;
    }
    return encodeAnyArray(settingArr);
}

/**
 * Decode settings from QR code data string
 * @param qr data string from QR code
 * @returns Decoded settings
 */
export function decodeSettingsFromQRCodeData(qr: string): ObsidianLiveSyncSettings {
    const settingArr = decodeAnyArray(qr);
    const fullIndexes = Object.entries(KeyIndexOfSettings) as [keyof ObsidianLiveSyncSettings, number][];
    const newSettings = { ...DEFAULT_SETTINGS } as ObsidianLiveSyncSettings;
    for (const [settingKey, index] of fullIndexes) {
        if (index < 0) {
            // This setting should be ignored.
            continue;
        }
        if (index >= settingArr.length) {
            // Possibly a new setting added.
            continue;
        }
        const settingValue = settingArr[index];
        //@ts-ignore
        newSettings[settingKey] = settingValue;
    }
    return newSettings;
}

export const enum OutputFormat {
    SVG = 0,
    ASCII = 1,
}

/**
 * Encode setting string to QR code in specified format
 * @param settingString Setting string to encode
 * @param format Output format
 */
export function encodeQR(settingString: string, format: OutputFormat) {
    const qr = qrcode(0, "L");
    const uri = `${configURIBaseQR}${encodeURIComponent(settingString)}`;
    qr.addData(uri);
    qr.make();
    if (format === OutputFormat.SVG) {
        return qr.createSvgTag(3);
    } else if (format === OutputFormat.ASCII) {
        return qr.createASCII(3);
    }
    return "";
}

type ErasureProperties = keyof ObsidianLiveSyncSettings;

/**
 * Properties that will always be removed when encoding settings to setup URI
 * These properties generated by other informations, so this is meaningless to include them in the URI.
 */
const necessaryErasureProperties: ErasureProperties[] = [
    "configPassphraseStore",
    "encryptedCouchDBConnection",
    "encryptedPassphrase",
];

/**
 * Generate setup URI with encrypted settings
 * @param settingString Settings to encode
 * @param passphrase Passphrase to encrypt the settings
 * @param removeProperties Properties to remove from the settings
 * Means these properties will not be included in the generated setup URI,
 * See also necessaryErasureProperties for properties that will always be removed.
 * @param skipDefaultValue Whether to skip default values
 * @returns Generated setup URI
 */
export async function encodeSettingsToSetupURI(
    settingString: ObsidianLiveSyncSettings,
    passphrase: string,
    removeProperties: ErasureProperties[] = ["pluginSyncExtendedSetting"],
    skipDefaultValue = false
) {
    const setting = {
        ...settingString,
    };
    if (skipDefaultValue) {
        const keys = Object.keys(setting) as (keyof ObsidianLiveSyncSettings)[];
        for (const k of keys) {
            if (
                JSON.stringify(k in setting ? setting[k] : "") ==
                JSON.stringify(k in DEFAULT_SETTINGS ? DEFAULT_SETTINGS[k] : "*")
            ) {
                delete setting[k];
            }
        }
    }
    for (const prop of [...removeProperties]) {
        delete setting[prop];
    }
    for (const prop of necessaryErasureProperties) {
        //@ts-ignore
        setting[prop] = "";
    }
    const encryptedSetting = encodeURIComponent(await encryptString(JSON.stringify(setting), passphrase));
    const uri = `${configURIBase}${encryptedSetting} `;
    return uri;
}

export async function decodeSettingsFromSetupURI(uri: string, passphrase: string) {
    const encryptedSetting = uri.substring(configURIBase.length);
    const decrypted = await decryptString(decodeURIComponent(encryptedSetting), passphrase);
    try {
        return JSON.parse(decrypted) as ObsidianLiveSyncSettings;
    } catch (e) {
        Logger(`Failed to parse settings from decrypted data`, LOG_LEVEL_NOTICE);
        Logger(e, LOG_LEVEL_VERBOSE);
        return false;
    }
}
